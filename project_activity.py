# Using the point_to_patch_weight.pkl file generated by the closest_point_to_patch.py function
# and the patch activation values from ICA-decomposed ECoG data from Julie, this script will
# calculate the activity of each point in the point cloud and then LeadField Matrix.
# The LeadField Matrix will be used to simulate the EEG data.

# %% initialize
import os
import numpy as np
import pickle
import matplotlib.pyplot as plt
import mne
from scipy.interpolate import griddata
from scipy.io import savemat
from multiprocessing import Pool
from os.path import join

patch_path = 'multi-patch'
ply_file = 'multi_patch_5'
# flag to shift activation values for multiple patches by 17 multiplicative factors
# 17 is just a random number to shift the activation values.
shift_activation = True
# read the patch numbber from the ply_file name
patch_number = int(ply_file.split('_')[-1])

# %% load data
# load the point to patch weight adn patch center coordinates
with open(join(patch_path, ply_file + '_ptpw.pkl'), 'rb') as f:
    point_to_patch_weight = pickle.load(f)
with open(join(patch_path, ply_file + '_pc.pkl'), 'rb') as f:
    patch_center_coordinates = pickle.load(f)

# Patch centers are coordinates in 3D space, they should be in the same space as the electrode positions,
# which is in a 2D plane. Find the least variable dimension and remove it.
patch_center_coordinates = np.delete(
    patch_center_coordinates, np.std(patch_center_coordinates, axis=0).argmin(), axis=1)

# load the patch activation values
ECoG = mne.io.read_raw_eeglab('CS_FullMotor500Hz_475.set')
ECoG_data = ECoG.get_data()
electrode_positions = ECoG.info.get_montage().get_positions()['ch_pos']
# remove the last dimension from the electrode positions, knowing that electrode positions are
# a dictionary of 3D coordinates. Still keep the dictionary style with keys being the electrode names.
electrode_positions = {key: np.delete(electrode_positions[key], 2) for key in electrode_positions}

# %% overlay the patch and electrode positions.
# Find the center of the electrode positions and the patches and remove the mean from both.
electrode_center = np.mean(list(electrode_positions.values()), axis=0)
patch_center = np.mean(patch_center_coordinates, axis=0)
# remove the mean from both
electrode_positions = {key: electrode_positions[key] - electrode_center for key in electrode_positions}
patch_center_coordinates = patch_center_coordinates - patch_center

# %% Scale the patch centers to match the electrode positions
patch_center_coordinates = patch_center_coordinates * 0.01

# get the range of the electrode positions and the patch centers in both dimensions
electrode_range = np.ptp(np.array(list(electrode_positions.values())), axis=0)
patch_range = np.ptp(patch_center_coordinates, axis=0)

# scale the patch centers to match the electrode positions in both dimensions
patch_center_coordinates = patch_center_coordinates * (electrode_range / patch_range)

# scaling makes misalignment. The lower left corner (min x, max y) of the electrode positions
# and patch should be the same
patch_center_coordinates = patch_center_coordinates + np.min(list(electrode_positions.values()), axis=0) -\
    np.min(patch_center_coordinates, axis=0)

# Plot the electrode positions and the patch centers
plt.figure()
plt.scatter(patch_center_coordinates[:, 0], patch_center_coordinates[:, 1], label='Patch Centers', color='red')
for key in electrode_positions:
    plt.scatter(electrode_positions[key][0], electrode_positions[key][1], label='Electrodes', color='blue')

# %% Create a dictionary of the closest patch to each electrode, ensure only one patch is assigned to each electrode.
closest_patch = {}
for key in electrode_positions:
    distances = np.linalg.norm(patch_center_coordinates - electrode_positions[key], axis=1)
    closest_patch[key] = np.argmin(distances)

# double check if the closest patch is unique
if len(set(closest_patch.values())) != len(closest_patch):
    print('Error: Some electrodes are assigned to the same patch. Check the code')
else:
    print('All electrodes are assigned to a unique patch')

# %% The following code currently gets into an infinite loop. The code is commented out for now.
# %% Accommodate for the patches with no assigned electrode
# Using patches with assigned electrodes and spline gird interpolation, estimate the patch activation values.
# Then assign the estimated activation values to the patches with no assigned electrodes.
# This is done to ensure that the LeadField matrix is smooth.

# create the patch grid for interpolation
x = np.linspace(np.min(patch_center_coordinates[:, 0]), np.max(patch_center_coordinates[:, 0]), 32)
y = np.linspace(np.min(patch_center_coordinates[:, 1]), np.max(patch_center_coordinates[:, 1]), 32)
X, Y = np.meshgrid(x, y)

# %% Assign the patch activation values
# but first if the shift_activation flag is True, shift the activation values by 17 multiplicative factors first
if shift_activation:
    shift = 17 * patch_number
    # now toss the first shift values to the end
    ECoG_data = np.roll(ECoG_data, -shift, axis=1)

# %% assign the patch activation values
patch_activation = np.full((len(patch_center_coordinates), ECoG_data.shape[1]), np.nan)
for key in closest_patch:
    patch_activation[closest_patch[key]] = ECoG_data[ECoG.ch_names.index(key)]

# check how many patches have nan values
num_nan_patches = sum(np.sum(np.isnan(patch_activation), axis=1) == 0)
print(f'{num_nan_patches} patches have non nan values')

# # Define a function to interpolate the patch activation values using griddata from the known patches
# def interpolate(i):
#     valid_mask = ~np.isnan(patch_activation[:, i])
#     return griddata(patch_center_coordinates[valid_mask], patch_activation[valid_mask, i], (X, Y), method='cubic')


# # Use multiprocessing to parallelize the interpolation
# with Pool(12) as p:  # 12 cores, change as needed
#     patch_activation_interpolated = np.array(p.map(interpolate, range(ECoG_data.shape[1])))

# patch_activation_interpolated = np.transpose(
#     patch_activation_interpolated, (1, 2, 0))  # reshape to (32, 32, ECoG_data.shape[1])


# %% Using the known patches, calculate the point cloud activation values
# The point cloud activation values are the weighted sum of the patch activation values.
# The weights are in the point_to_patch_weight dict.
# The keys of the dictionary are the point cloud indices and the values are the patch index followed by the weight.
# For example {0: [1,0.5, 2, 0.3]} means that the point 0 activation value is 0.5*patch1 + 0.3*patch2.
# If the interpolation above is not used, then not all the patches will have activation values.
# So, check for nan values and remove them from the calculation.
point_activation = np.zeros((len(point_to_patch_weight), ECoG_data.shape[1]))
for i, key in enumerate(point_to_patch_weight):
    for j in range(0, len(point_to_patch_weight[key])):
        if not np.isnan(patch_activation[point_to_patch_weight[key][j][0]]).all():
            point_activation[i] +=\
                patch_activation[point_to_patch_weight[key][j][0]] * point_to_patch_weight[key][j][1]

# %% check if the point activation values are all zero
if np.all(point_activation == 0):
    print('All point activation values are zero. Check the code')

# # %% plot the first 10k points of the non-zero point_activation values
# plt.figure()
# for i in range(10000):
#     plt.plot(point_activation[i])
# plt.show()

# %% save the point activation values
# convert point_activation to a dict with the keys being the keys fo the point_to_patch_weight dict
point_activation_dict = {key: point_activation[i] for i, key in enumerate(point_to_patch_weight)}

with open(join(patch_path, ply_file + '_point_activation.pkl'), 'wb') as f:
    pickle.dump(point_activation_dict, f)
# save point_activation data and the LFM indices as fields in a .mat file
savemat(
    join(patch_path, ply_file + '_point_activation.mat'),
    {'point_activation': point_activation, 'LFM_indices': list(point_to_patch_weight.keys())}
)
